{"ast":null,"code":"import _asyncToGenerator from \"/home/imstaked/explorer/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"/home/imstaked/explorer/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/imstaked/explorer/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport \"regenerator-runtime/runtime.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport { pathToString } from '@cosmjs/crypto';\nimport { fromHex } from '@cosmjs/encoding';\nimport { ethToEvmos } from '@tharsis/address-converter';\n\nvar MetaMaskSigner = /*#__PURE__*/function () {\n  function MetaMaskSigner() {\n    _classCallCheck(this, MetaMaskSigner);\n  }\n\n  _createClass(MetaMaskSigner, [{\n    key: \"getAccounts\",\n    value: function () {\n      var _getAccounts = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.ethereum.request({\n                  method: 'eth_accounts'\n                }).then(function (data) {\n                  return data.map(function (x) {\n                    return {\n                      pubkey: fromHex(x.substring(2)),\n                      // should set to public key\n                      address: ethToEvmos(x),\n                      algo: 'ethsecp256k1'\n                    };\n                  });\n                }));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getAccounts() {\n        return _getAccounts.apply(this, arguments);\n      }\n\n      return getAccounts;\n    }()\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(signer, eipToSign) {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.ethereum.request({\n                  method: 'eth_signTypedData_v4',\n                  params: [signer, JSON.stringify(eipToSign)]\n                }));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function sign(_x, _x2) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }() // signAmino: (signerAddress: string, signDoc: StdSignDoc) => Promise<AminoSignResponse>;\n\n  }], [{\n    key: \"create\",\n    value: function create(hdpath) {\n      var signer = new MetaMaskSigner();\n      signer.hdpath = pathToString(hdpath).replace('m/', '').replace('/60/', \"/60'/\");\n      signer.ethereum = window.ethereum;\n      return signer;\n    }\n  }]);\n\n  return MetaMaskSigner;\n}();\n\nexport { MetaMaskSigner as default };","map":{"version":3,"names":["pathToString","fromHex","ethToEvmos","MetaMaskSigner","ethereum","request","method","then","data","map","x","pubkey","substring","address","algo","signer","eipToSign","params","JSON","stringify","hdpath","replace","window"],"sources":["/home/imstaked/explorer/src/libs/client/MetaMaskSigner.js"],"sourcesContent":["import { pathToString } from '@cosmjs/crypto'\nimport { fromHex } from '@cosmjs/encoding'\nimport { ethToEvmos } from '@tharsis/address-converter'\n\nexport default class MetaMaskSigner {\n  static create(hdpath) {\n    const signer = new MetaMaskSigner()\n    signer.hdpath = pathToString(hdpath).replace('m/', '').replace('/60/', \"/60'/\")\n    signer.ethereum = window.ethereum\n    return signer\n  }\n\n  async getAccounts() {\n    // eth_accounts, eth_requestAccounts\n    return this.ethereum.request({ method: 'eth_accounts' }).then(data => data.map(x => ({\n      pubkey: fromHex(x.substring(2)), // should set to public key\n      address: ethToEvmos(x),\n      algo: 'ethsecp256k1',\n    })))\n  }\n\n  async sign(signer, eipToSign) {\n    return this.ethereum.request({\n      method: 'eth_signTypedData_v4',\n      params: [signer, JSON.stringify(eipToSign)],\n    })\n  }\n  // signAmino: (signerAddress: string, signDoc: StdSignDoc) => Promise<AminoSignResponse>;\n}\n"],"mappings":";;;;;;;;AAAA,SAASA,YAAT,QAA6B,gBAA7B;AACA,SAASC,OAAT,QAAwB,kBAAxB;AACA,SAASC,UAAT,QAA2B,4BAA3B;;IAEqBC,c;;;;;;;;iFAQnB;QAAA;UAAA;YAAA;cAAA;gBAAA,iCAES,KAAKC,QAAL,CAAcC,OAAd,CAAsB;kBAAEC,MAAM,EAAE;gBAAV,CAAtB,EAAkDC,IAAlD,CAAuD,UAAAC,IAAI;kBAAA,OAAIA,IAAI,CAACC,GAAL,CAAS,UAAAC,CAAC;oBAAA,OAAK;sBACnFC,MAAM,EAAEV,OAAO,CAACS,CAAC,CAACE,SAAF,CAAY,CAAZ,CAAD,CADoE;sBAClD;sBACjCC,OAAO,EAAEX,UAAU,CAACQ,CAAD,CAFgE;sBAGnFI,IAAI,EAAE;oBAH6E,CAAL;kBAAA,CAAV,CAAJ;gBAAA,CAA3D,CAFT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;;;;;0EASA,kBAAWC,MAAX,EAAmBC,SAAnB;QAAA;UAAA;YAAA;cAAA;gBAAA,kCACS,KAAKZ,QAAL,CAAcC,OAAd,CAAsB;kBAC3BC,MAAM,EAAE,sBADmB;kBAE3BW,MAAM,EAAE,CAACF,MAAD,EAASG,IAAI,CAACC,SAAL,CAAeH,SAAf,CAAT;gBAFmB,CAAtB,CADT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,C;;;;;;;QAMA;;;;WAtBA,gBAAcI,MAAd,EAAsB;MACpB,IAAML,MAAM,GAAG,IAAIZ,cAAJ,EAAf;MACAY,MAAM,CAACK,MAAP,GAAgBpB,YAAY,CAACoB,MAAD,CAAZ,CAAqBC,OAArB,CAA6B,IAA7B,EAAmC,EAAnC,EAAuCA,OAAvC,CAA+C,MAA/C,EAAuD,OAAvD,CAAhB;MACAN,MAAM,CAACX,QAAP,GAAkBkB,MAAM,CAAClB,QAAzB;MACA,OAAOW,MAAP;IACD;;;;;;SANkBZ,c"},"metadata":{},"sourceType":"module"}